# coding: utf-8

"""
    

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.11.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from oxford_dictionaries_api.api_client import ApiClient


class LexiStatsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def stats_frequency_ngrams_source_lang_corpus_ngram_size_get(self, source_lang, corpus, ngram_size, app_id, app_key, **kwargs):  # noqa: E501
        """Retrieve the frequency of ngrams (1-4) derived from a corpus  # noqa: E501

        This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size = 1) or words (ngram size > 1) appear in the corpus. Ngrams are case sensitive (\"I AM\" and \"I am\" will have different frequency) and frequencies are calculated per word (true case) so \"the book\" and \"the books\" are two different ngrams. The results can be filtered based on query parameters. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> Example for bigrams (ngram of size 2): * PATH: /tokens=a word,another word * GET: /?tokens=a word&tokens=another word * POST (json):    ```javascript     {         \"tokens\": [\"a word\", \"another word\"]     }   ```  Either \"tokens\" or \"contains\" has to be provided. <br> <br> Some queries with \"contains\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python's `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()['results']:           yield item         url = r.links.get('next', {}).get('url') ```   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stats_frequency_ngrams_source_lang_corpus_ngram_size_get(source_lang, corpus, ngram_size, app_id, app_key, async=True)
        >>> result = thread.get()

        :param async bool
        :param str source_lang: IANA language code (required)
        :param str corpus: For corpora other than 'nmc' (New Monitor Corpus) please contact api@oxforddictionaries.com (required)
        :param str ngram_size: the size of ngrams requested (1-4) (required)
        :param str app_id: App ID Authentication Parameter (required)
        :param str app_key: App Key Authentication Parameter (required)
        :param str tokens: List of tokens to filter. The tokens are separated by spaces, the list items are separated by comma (e.g., for bigrams (n=2) tokens=this is,this was, this will)
        :param str contains: Find ngrams containing the given token(s). Use comma or space as token separators; the order of tokens is irrelevant.
        :param str punctuation: Flag specifying whether to lookup ngrams that include punctuation or not (possible values are \"true\" and \"false\"; default is \"false\")
        :param str format: Option specifying whether tokens should be returned as a single string (option \"google\") or as a list of strings (option \"oup\")
        :param int min_frequency: Restrict the query to entries with frequency of at least `minFrequency`
        :param int max_frequency: Restrict the query to entries with frequency of at most `maxFrequency`
        :param int min_document_frequency: Restrict the query to entries that appear in at least `minDocumentFrequency` documents
        :param int max_document_frequency: Restrict the query to entries that appera in at most `maxDocumentFrequency` documents
        :param str collate: collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate=trueCase,lemma,lexicalCategory).
        :param str sort: sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign ('-'). Multiple values can be separated by commas (e.g., sort=lexicalCategory,-frequency)
        :param int offset: pagination - results offset
        :param int limit: pagination - results limit
        :return: NgramsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stats_frequency_ngrams_source_lang_corpus_ngram_size_get_with_http_info(source_lang, corpus, ngram_size, app_id, app_key, **kwargs)  # noqa: E501
        else:
            (data) = self.stats_frequency_ngrams_source_lang_corpus_ngram_size_get_with_http_info(source_lang, corpus, ngram_size, app_id, app_key, **kwargs)  # noqa: E501
            return data

    def stats_frequency_ngrams_source_lang_corpus_ngram_size_get_with_http_info(self, source_lang, corpus, ngram_size, app_id, app_key, **kwargs):  # noqa: E501
        """Retrieve the frequency of ngrams (1-4) derived from a corpus  # noqa: E501

        This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size = 1) or words (ngram size > 1) appear in the corpus. Ngrams are case sensitive (\"I AM\" and \"I am\" will have different frequency) and frequencies are calculated per word (true case) so \"the book\" and \"the books\" are two different ngrams. The results can be filtered based on query parameters. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> Example for bigrams (ngram of size 2): * PATH: /tokens=a word,another word * GET: /?tokens=a word&tokens=another word * POST (json):    ```javascript     {         \"tokens\": [\"a word\", \"another word\"]     }   ```  Either \"tokens\" or \"contains\" has to be provided. <br> <br> Some queries with \"contains\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python's `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()['results']:           yield item         url = r.links.get('next', {}).get('url') ```   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stats_frequency_ngrams_source_lang_corpus_ngram_size_get_with_http_info(source_lang, corpus, ngram_size, app_id, app_key, async=True)
        >>> result = thread.get()

        :param async bool
        :param str source_lang: IANA language code (required)
        :param str corpus: For corpora other than 'nmc' (New Monitor Corpus) please contact api@oxforddictionaries.com (required)
        :param str ngram_size: the size of ngrams requested (1-4) (required)
        :param str app_id: App ID Authentication Parameter (required)
        :param str app_key: App Key Authentication Parameter (required)
        :param str tokens: List of tokens to filter. The tokens are separated by spaces, the list items are separated by comma (e.g., for bigrams (n=2) tokens=this is,this was, this will)
        :param str contains: Find ngrams containing the given token(s). Use comma or space as token separators; the order of tokens is irrelevant.
        :param str punctuation: Flag specifying whether to lookup ngrams that include punctuation or not (possible values are \"true\" and \"false\"; default is \"false\")
        :param str format: Option specifying whether tokens should be returned as a single string (option \"google\") or as a list of strings (option \"oup\")
        :param int min_frequency: Restrict the query to entries with frequency of at least `minFrequency`
        :param int max_frequency: Restrict the query to entries with frequency of at most `maxFrequency`
        :param int min_document_frequency: Restrict the query to entries that appear in at least `minDocumentFrequency` documents
        :param int max_document_frequency: Restrict the query to entries that appera in at most `maxDocumentFrequency` documents
        :param str collate: collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate=trueCase,lemma,lexicalCategory).
        :param str sort: sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign ('-'). Multiple values can be separated by commas (e.g., sort=lexicalCategory,-frequency)
        :param int offset: pagination - results offset
        :param int limit: pagination - results limit
        :return: NgramsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['source_lang', 'corpus', 'ngram_size', 'app_id', 'app_key', 'tokens', 'contains', 'punctuation', 'format', 'min_frequency', 'max_frequency', 'min_document_frequency', 'max_document_frequency', 'collate', 'sort', 'offset', 'limit']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stats_frequency_ngrams_source_lang_corpus_ngram_size_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'source_lang' is set
        if ('source_lang' not in params or
                params['source_lang'] is None):
            raise ValueError("Missing the required parameter `source_lang` when calling `stats_frequency_ngrams_source_lang_corpus_ngram_size_get`")  # noqa: E501
        # verify the required parameter 'corpus' is set
        if ('corpus' not in params or
                params['corpus'] is None):
            raise ValueError("Missing the required parameter `corpus` when calling `stats_frequency_ngrams_source_lang_corpus_ngram_size_get`")  # noqa: E501
        # verify the required parameter 'ngram_size' is set
        if ('ngram_size' not in params or
                params['ngram_size'] is None):
            raise ValueError("Missing the required parameter `ngram_size` when calling `stats_frequency_ngrams_source_lang_corpus_ngram_size_get`")  # noqa: E501
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `stats_frequency_ngrams_source_lang_corpus_ngram_size_get`")  # noqa: E501
        # verify the required parameter 'app_key' is set
        if ('app_key' not in params or
                params['app_key'] is None):
            raise ValueError("Missing the required parameter `app_key` when calling `stats_frequency_ngrams_source_lang_corpus_ngram_size_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source_lang' in params:
            path_params['source_lang'] = params['source_lang']  # noqa: E501
        if 'corpus' in params:
            path_params['corpus'] = params['corpus']  # noqa: E501
        if 'ngram_size' in params:
            path_params['ngram-size'] = params['ngram_size']  # noqa: E501

        query_params = []
        if 'tokens' in params:
            query_params.append(('tokens', params['tokens']))  # noqa: E501
        if 'contains' in params:
            query_params.append(('contains', params['contains']))  # noqa: E501
        if 'punctuation' in params:
            query_params.append(('punctuation', params['punctuation']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'min_frequency' in params:
            query_params.append(('minFrequency', params['min_frequency']))  # noqa: E501
        if 'max_frequency' in params:
            query_params.append(('maxFrequency', params['max_frequency']))  # noqa: E501
        if 'min_document_frequency' in params:
            query_params.append(('minDocumentFrequency', params['min_document_frequency']))  # noqa: E501
        if 'max_document_frequency' in params:
            query_params.append(('maxDocumentFrequency', params['max_document_frequency']))  # noqa: E501
        if 'collate' in params:
            query_params.append(('collate', params['collate']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}
        if 'app_id' in params:
            header_params['app_id'] = params['app_id']  # noqa: E501
        if 'app_key' in params:
            header_params['app_key'] = params['app_key']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stats/frequency/ngrams/{source_lang}/{corpus}/{ngram-size}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NgramsResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stats_frequency_word_source_lang_get(self, source_lang, app_id, app_key, **kwargs):  # noqa: E501
        """Retrieve the frequency of a word derived from a corpus.  # noqa: E501

        This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma=test, the returned frequency will include the verb \"test\", the noun \"test\" and the adjective \"test\" in all forms (Test, tested, testing, etc.) <br> <br> If you are interested in the frequency of the word \"test\" but want to exclude other forms (e.g., tested) use the option trueCase=test. Normally, the word \"test\" will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \"Test\" and \"test\" as the same token. If you are interested in frequencies of \"Test\" and \"test\", use the option wordform=test or wordform=Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \"press\" in Oxford University Press. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma=test;lexicalCategory=noun * GET: /?lemma=test&lexicalCategory=noun * POST (json):    ```javascript     {       \"lemma\": \"test\",       \"lexicalCategory\": \"noun\"     }   ```  <br> One of the options wordform/trueCase/lemma/lexicalCategory has to be provided.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stats_frequency_word_source_lang_get(source_lang, app_id, app_key, async=True)
        >>> result = thread.get()

        :param async bool
        :param str source_lang: IANA language code (required)
        :param str app_id: App ID Authentication Parameter (required)
        :param str app_key: App Key Authentication Parameter (required)
        :param str corpus: For corpora other than 'nmc' (New Monitor Corpus) please contact api@oxforddictionaries.com
        :param str wordform: The written form of the word to look up (preserving case e.g., Books vs books)
        :param str true_case: The written form of the word to look up with normalised case (Books --> books)
        :param str lemma: The lemma of the word to look up (e.g., Book, booked, books all have the lemma \"book\")
        :param str lexical_category: The lexical category of the word(s) to look up (e.g., noun or verb)
        :return: StatsWordResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stats_frequency_word_source_lang_get_with_http_info(source_lang, app_id, app_key, **kwargs)  # noqa: E501
        else:
            (data) = self.stats_frequency_word_source_lang_get_with_http_info(source_lang, app_id, app_key, **kwargs)  # noqa: E501
            return data

    def stats_frequency_word_source_lang_get_with_http_info(self, source_lang, app_id, app_key, **kwargs):  # noqa: E501
        """Retrieve the frequency of a word derived from a corpus.  # noqa: E501

        This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma=test, the returned frequency will include the verb \"test\", the noun \"test\" and the adjective \"test\" in all forms (Test, tested, testing, etc.) <br> <br> If you are interested in the frequency of the word \"test\" but want to exclude other forms (e.g., tested) use the option trueCase=test. Normally, the word \"test\" will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \"Test\" and \"test\" as the same token. If you are interested in frequencies of \"Test\" and \"test\", use the option wordform=test or wordform=Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \"press\" in Oxford University Press. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma=test;lexicalCategory=noun * GET: /?lemma=test&lexicalCategory=noun * POST (json):    ```javascript     {       \"lemma\": \"test\",       \"lexicalCategory\": \"noun\"     }   ```  <br> One of the options wordform/trueCase/lemma/lexicalCategory has to be provided.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stats_frequency_word_source_lang_get_with_http_info(source_lang, app_id, app_key, async=True)
        >>> result = thread.get()

        :param async bool
        :param str source_lang: IANA language code (required)
        :param str app_id: App ID Authentication Parameter (required)
        :param str app_key: App Key Authentication Parameter (required)
        :param str corpus: For corpora other than 'nmc' (New Monitor Corpus) please contact api@oxforddictionaries.com
        :param str wordform: The written form of the word to look up (preserving case e.g., Books vs books)
        :param str true_case: The written form of the word to look up with normalised case (Books --> books)
        :param str lemma: The lemma of the word to look up (e.g., Book, booked, books all have the lemma \"book\")
        :param str lexical_category: The lexical category of the word(s) to look up (e.g., noun or verb)
        :return: StatsWordResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['source_lang', 'app_id', 'app_key', 'corpus', 'wordform', 'true_case', 'lemma', 'lexical_category']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stats_frequency_word_source_lang_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'source_lang' is set
        if ('source_lang' not in params or
                params['source_lang'] is None):
            raise ValueError("Missing the required parameter `source_lang` when calling `stats_frequency_word_source_lang_get`")  # noqa: E501
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `stats_frequency_word_source_lang_get`")  # noqa: E501
        # verify the required parameter 'app_key' is set
        if ('app_key' not in params or
                params['app_key'] is None):
            raise ValueError("Missing the required parameter `app_key` when calling `stats_frequency_word_source_lang_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source_lang' in params:
            path_params['source_lang'] = params['source_lang']  # noqa: E501

        query_params = []
        if 'corpus' in params:
            query_params.append(('corpus', params['corpus']))  # noqa: E501
        if 'wordform' in params:
            query_params.append(('wordform', params['wordform']))  # noqa: E501
        if 'true_case' in params:
            query_params.append(('trueCase', params['true_case']))  # noqa: E501
        if 'lemma' in params:
            query_params.append(('lemma', params['lemma']))  # noqa: E501
        if 'lexical_category' in params:
            query_params.append(('lexicalCategory', params['lexical_category']))  # noqa: E501

        header_params = {}
        if 'app_id' in params:
            header_params['app_id'] = params['app_id']  # noqa: E501
        if 'app_key' in params:
            header_params['app_key'] = params['app_key']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stats/frequency/word/{source_lang}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatsWordResult',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stats_frequency_words_source_lang_get(self, source_lang, app_id, app_key, **kwargs):  # noqa: E501
        """Retrieve a list of frequencies of a word/words derived from a corpus.  # noqa: E501

        This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. <br> <br> To exclude a specific value, prepend it with the minus sign ('-'). For example, to get frequencies of the lemma 'happy' but exclude superlative forms (i.e., happiest) you could use options 'lemma=happy;grammaticalFeatures=-degreeType:superlative'. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms=happy,happier,happiest * GET: /?wordforms=happy&wordforms=happier&wordforms=happiest * POST (json): ```javascript   {     \"wordforms\": [\"happy\", \"happier\", \"happiest\"]   } ``` A mor complex example of retrieving frequencies of multiple lemmas: ```   {       \"lemmas\": [\"happy\", \"content\", \"cheerful\", \"cheery\", \"merry\", \"joyful\", \"ecstatic\"],       \"grammaticalFeatures\": {           \"adjectiveFunctionType\": \"predicative\"       },       \"lexicalCategory\": \"adjective\",       \"sort\": [\"lemma\", \"-frequency\"]   } ``` Some queries with \"collate\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python's `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()['results']:           yield item         url = r.links.get('next', {}).get('url') ```   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stats_frequency_words_source_lang_get(source_lang, app_id, app_key, async=True)
        >>> result = thread.get()

        :param async bool
        :param str source_lang: IANA language code (required)
        :param str app_id: App ID Authentication Parameter (required)
        :param str app_key: App Key Authentication Parameter (required)
        :param str corpus: For corpora other than 'nmc' (New Monitor Corpus) please contact api@oxforddictionaries.com
        :param str wordform: The written form of the word to look up (preserving case e.g., Book vs book)
        :param str true_case: The written form of the word to look up with normalised case (Books --> books)
        :param str lemma: The lemma of the word to look up (e.g., Book, booked, books all have the lemma \"book\")
        :param str lexical_category: The lexical category of the word(s) to look up (e.g., adjective or noun)
        :param str grammatical_features: The grammatical features of the word(s) to look up entered as a list of k:v (e.g., degree_type:comparative)
        :param str sort: sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign ('-'). Multiple values can be separated by commas (e.g., sort=lexicalCategory,-frequency)
        :param str collate: collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate=trueCase,lemma,lexicalCategory).
        :param int min_frequency: Restrict the query to entries with frequency of at least `minFrequency`
        :param int max_frequency: Restrict the query to entries with frequency of at most `maxFrequency`
        :param float min_normalized_frequency: Restrict the query to entries with frequency of at least `minNormalizedFrequency`
        :param float max_normalized_frequency: Restrict the query to entries with frequency of at most `maxNormalizedFrequency`
        :param int offset: pagination - results offset
        :param int limit: pagination - results limit
        :return: StatsWordResultList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.stats_frequency_words_source_lang_get_with_http_info(source_lang, app_id, app_key, **kwargs)  # noqa: E501
        else:
            (data) = self.stats_frequency_words_source_lang_get_with_http_info(source_lang, app_id, app_key, **kwargs)  # noqa: E501
            return data

    def stats_frequency_words_source_lang_get_with_http_info(self, source_lang, app_id, app_key, **kwargs):  # noqa: E501
        """Retrieve a list of frequencies of a word/words derived from a corpus.  # noqa: E501

        This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. <br> <br> To exclude a specific value, prepend it with the minus sign ('-'). For example, to get frequencies of the lemma 'happy' but exclude superlative forms (i.e., happiest) you could use options 'lemma=happy;grammaticalFeatures=-degreeType:superlative'. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms=happy,happier,happiest * GET: /?wordforms=happy&wordforms=happier&wordforms=happiest * POST (json): ```javascript   {     \"wordforms\": [\"happy\", \"happier\", \"happiest\"]   } ``` A mor complex example of retrieving frequencies of multiple lemmas: ```   {       \"lemmas\": [\"happy\", \"content\", \"cheerful\", \"cheery\", \"merry\", \"joyful\", \"ecstatic\"],       \"grammaticalFeatures\": {           \"adjectiveFunctionType\": \"predicative\"       },       \"lexicalCategory\": \"adjective\",       \"sort\": [\"lemma\", \"-frequency\"]   } ``` Some queries with \"collate\" or \"sort\" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \"minFrequency\" and \"maxFrequency\". <br> <br> You can use the parameters \"offset\" and \"limit\" to paginate through large result sets. For convenience, the HTTP header \"Link\" is set on the response to provide links to \"first\", \"self\", \"next\", \"prev\" and \"last\" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \"limit\" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python's `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example: ```python def get_all_results(url):     while url:         r = requests.get(url)         r.raise_for_status()         for item in r.json()['results']:           yield item         url = r.links.get('next', {}).get('url') ```   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.stats_frequency_words_source_lang_get_with_http_info(source_lang, app_id, app_key, async=True)
        >>> result = thread.get()

        :param async bool
        :param str source_lang: IANA language code (required)
        :param str app_id: App ID Authentication Parameter (required)
        :param str app_key: App Key Authentication Parameter (required)
        :param str corpus: For corpora other than 'nmc' (New Monitor Corpus) please contact api@oxforddictionaries.com
        :param str wordform: The written form of the word to look up (preserving case e.g., Book vs book)
        :param str true_case: The written form of the word to look up with normalised case (Books --> books)
        :param str lemma: The lemma of the word to look up (e.g., Book, booked, books all have the lemma \"book\")
        :param str lexical_category: The lexical category of the word(s) to look up (e.g., adjective or noun)
        :param str grammatical_features: The grammatical features of the word(s) to look up entered as a list of k:v (e.g., degree_type:comparative)
        :param str sort: sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign ('-'). Multiple values can be separated by commas (e.g., sort=lexicalCategory,-frequency)
        :param str collate: collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate=trueCase,lemma,lexicalCategory).
        :param int min_frequency: Restrict the query to entries with frequency of at least `minFrequency`
        :param int max_frequency: Restrict the query to entries with frequency of at most `maxFrequency`
        :param float min_normalized_frequency: Restrict the query to entries with frequency of at least `minNormalizedFrequency`
        :param float max_normalized_frequency: Restrict the query to entries with frequency of at most `maxNormalizedFrequency`
        :param int offset: pagination - results offset
        :param int limit: pagination - results limit
        :return: StatsWordResultList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['source_lang', 'app_id', 'app_key', 'corpus', 'wordform', 'true_case', 'lemma', 'lexical_category', 'grammatical_features', 'sort', 'collate', 'min_frequency', 'max_frequency', 'min_normalized_frequency', 'max_normalized_frequency', 'offset', 'limit']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stats_frequency_words_source_lang_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'source_lang' is set
        if ('source_lang' not in params or
                params['source_lang'] is None):
            raise ValueError("Missing the required parameter `source_lang` when calling `stats_frequency_words_source_lang_get`")  # noqa: E501
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `stats_frequency_words_source_lang_get`")  # noqa: E501
        # verify the required parameter 'app_key' is set
        if ('app_key' not in params or
                params['app_key'] is None):
            raise ValueError("Missing the required parameter `app_key` when calling `stats_frequency_words_source_lang_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source_lang' in params:
            path_params['source_lang'] = params['source_lang']  # noqa: E501

        query_params = []
        if 'corpus' in params:
            query_params.append(('corpus', params['corpus']))  # noqa: E501
        if 'wordform' in params:
            query_params.append(('wordform', params['wordform']))  # noqa: E501
        if 'true_case' in params:
            query_params.append(('trueCase', params['true_case']))  # noqa: E501
        if 'lemma' in params:
            query_params.append(('lemma', params['lemma']))  # noqa: E501
        if 'lexical_category' in params:
            query_params.append(('lexicalCategory', params['lexical_category']))  # noqa: E501
        if 'grammatical_features' in params:
            query_params.append(('grammaticalFeatures', params['grammatical_features']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'collate' in params:
            query_params.append(('collate', params['collate']))  # noqa: E501
        if 'min_frequency' in params:
            query_params.append(('minFrequency', params['min_frequency']))  # noqa: E501
        if 'max_frequency' in params:
            query_params.append(('maxFrequency', params['max_frequency']))  # noqa: E501
        if 'min_normalized_frequency' in params:
            query_params.append(('minNormalizedFrequency', params['min_normalized_frequency']))  # noqa: E501
        if 'max_normalized_frequency' in params:
            query_params.append(('maxNormalizedFrequency', params['max_normalized_frequency']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}
        if 'app_id' in params:
            header_params['app_id'] = params['app_id']  # noqa: E501
        if 'app_key' in params:
            header_params['app_key'] = params['app_key']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stats/frequency/words/{source_lang}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatsWordResultList',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
